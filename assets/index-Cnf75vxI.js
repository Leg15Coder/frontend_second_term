const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/App-BXBS0YwB.js","assets/vendor-CEayKMPr.js","assets/App-BbG9hNBP.css"])))=>i.map(i=>d[i]);
import{g as ot,i as at,a as nt,b as st,c as it,d as Ge,e as $e,f as h,h as g,u as y,j as J,k as ue,l as O,m as H,n as A,q as pe,w as fe,o as _,p as dt,r as f,s as T,t as ct,v as lt,x as Ce,y as ut,G as pt,z as ft,A as gt,B as Se,C as ht,D as Le,E as mt,F as wt,H as j,T as ge,I as yt,J as Ct,K as St,L as Et,M as Ee,P as At}from"./vendor-CEayKMPr.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))o(a);new MutationObserver(a=>{for(const n of a)if(n.type==="childList")for(const s of n.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&o(s)}).observe(document,{childList:!0,subtree:!0});function r(a){const n={};return a.integrity&&(n.integrity=a.integrity),a.referrerPolicy&&(n.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?n.credentials="include":a.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function o(a){if(a.ep)return;a.ep=!0;const n=r(a);fetch(a.href,n)}})();const Dt="modulepreload",It=function(t){return"/"+t},Ae={},he=function(e,r,o){let a=Promise.resolve();if(r&&r.length>0){let c=function(d){return Promise.all(d.map(u=>Promise.resolve(u).then(m=>({status:"fulfilled",value:m}),m=>({status:"rejected",reason:m}))))};document.getElementsByTagName("link");const s=document.querySelector("meta[property=csp-nonce]"),i=s?.nonce||s?.getAttribute("nonce");a=c(r.map(d=>{if(d=It(d),d in Ae)return;Ae[d]=!0;const u=d.endsWith(".css"),m=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${d}"]${m}`))return;const w=document.createElement("link");if(w.rel=u?"stylesheet":Dt,u||(w.as="script"),w.crossOrigin="",w.href=d,i&&w.setAttribute("nonce",i),document.head.appendChild(w),u)return new Promise((S,b)=>{w.addEventListener("load",S),w.addEventListener("error",()=>b(new Error(`Unable to preload CSS for ${d}`)))})}))}function n(s){const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=s,window.dispatchEvent(i),!i.defaultPrevented)throw s}return a.then(s=>{for(const i of s||[])i.status==="rejected"&&n(i.reason);return e().catch(n)})};function kt(){const t={apiKey:void 0,authDomain:void 0,projectId:void 0,storageBucket:void 0,messagingSenderId:void 0,appId:void 0,measurementId:void 0},e=Object.entries(t).filter(([,r])=>!r);if(e.length>0){const r=`Firebase configuration error: Missing keys: ${e.map(o=>o[0]).join(", ")}`;throw new Error(r)}return t}const He=kt(),G=ot().length===0?at(He):nt(),l=st(G),p=it(G);async function _e(){}async function Ne(){if(!He.measurementId||typeof window>"u"||!await Ge().catch(()=>!1))return null;try{return $e(G)}catch{return null}}const je=Object.freeze(Object.defineProperty({__proto__:null,auth:l,connectEmulators:_e,db:p,default:G,initAnalytics:Ne},Symbol.toStringTag,{value:"Module"}));var bt={};const $="habits",vt=typeof process<"u"&&(bt.VITEST==="true"||!1)||typeof window<"u"&&typeof window.Cypress<"u"&&window.Cypress===!0,Ot=!(typeof process<"u"),Pe=new Map,Me=t=>`motify_habits_${t}`;function Ve(){return typeof window<"u"?window.localStorage:null}function x(t){if(!t)return[];const e=Me(t),r=Ve(),o=r?r.getItem(e):Pe.get(e);if(!o)return[];try{const a=JSON.parse(o);return Array.isArray(a)?a.map(n=>({...n})):[]}catch{return[]}}function R(t,e){if(!t)return[];const r=Me(t),o=JSON.stringify(e),a=Ve();return a?a.setItem(r,o):Pe.set(r,o),e}const z={async getHabits(t){return x(t)},async addHabit(t){const e=x(t.userId),r={...t,id:typeof crypto<"u"&&crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),completed:t.completed??!1,streak:t.streak??0,datesCompleted:[...t.datesCompleted??[]]};return R(t.userId,[r,...e]),r},async updateHabit(t,e){const r=x(e.userId);let o=null;const a=r.map(n=>{if(n.id!==t)return n;const s={...n,...e,updatedAt:new Date().toISOString()};return o=s,s});if(!o)throw new Error("Habit not found");return R(e.userId,a),o},async deleteHabit(t,e){const r=x(e);R(e,r.filter(o=>o.id!==t))},async checkInHabit(t,e,r){const o=x(r);let a=null;const n=o.map(s=>{if(s.id!==t)return s;const i=new Set(s.datesCompleted??[]),c=i.has(e);c||i.add(e);const d=Array.from(i),u={...s,datesCompleted:d,completed:i.has(e),updatedAt:new Date().toISOString(),streak:c?s.streak??0:(s.streak??0)+1};return a=u,u});if(R(r,n),!a)throw new Error("Habit not found");return a}};function P(t){if(!t&&t!==0)return String(t);try{return typeof t=="object"&&typeof t.toDate=="function"?t.toDate().toISOString().split("T")[0]:t instanceof Date?t.toISOString().split("T")[0]:typeof t=="string"?t.split("T")[0]:String(t)}catch{return String(t)}}const xt={async getHabits(t){if(!t)return[];try{const e=pe(A(p,$),fe("userId","==",t)),o=(await _(e)).docs.map(a=>{const n=a.data(),s=Array.isArray(n.datesCompleted)?n.datesCompleted.map(P):[],i=typeof n.completed=="boolean"?n.completed:s.length>0;return{id:a.id,...n,datesCompleted:s,completed:i}});try{R(t,o)}catch{}return o}catch(e){return console.error("Error fetching habits from Firestore, falling back to local:",e),await z.getHabits(t)}},async addHabit(t){const e={...t,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),completed:t.completed??!1,streak:t.streak??0,datesCompleted:t.datesCompleted??[]},r=await H(A(p,$),e);return{...e,id:r.id}},async updateHabit(t,e){const r=h(p,$,t),o={...e,updatedAt:new Date().toISOString()},{id:a,...n}=o;try{console.log(`[remoteHabitsService] Updating habit ${t} with`,n),await y(r,n);const s=await g(r);if(!s.exists())throw new Error("Habit not found after update");console.log(`[remoteHabitsService] Habit ${t} updated successfully`);const i=s.data(),c=Array.isArray(i.datesCompleted)?i.datesCompleted.map(P):[],d=typeof i.completed=="boolean"?i.completed:c.length>0;return{id:s.id,...i,datesCompleted:c,completed:d}}catch(s){console.error(`[remoteHabitsService] Failed to update habit ${t}:`,s);const i=String(s?.code||s?.message||s);if(i.toLowerCase().includes("permission")||i.toLowerCase().includes("insufficient")){console.warn("[remoteHabitsService] Permission error — falling back to local update");try{return await z.updateHabit(t,e)}catch(c){throw console.error("[remoteHabitsService] Local fallback update failed:",c),s}}throw s}},async deleteHabit(t,e){await O(h(p,$,t))},async checkInHabit(t,e,r){const o=h(p,$,t);try{const a=await g(o);if(!a.exists())throw new Error("Habit not found");const n=a.data(),s=Array.isArray(n.datesCompleted)?n.datesCompleted.map(P):[],i=new Set(s),c=i.has(e);console.log(`[remoteHabitsService] checkInHabit ${t} current dates:`,s),console.log(`[remoteHabitsService] checkInHabit ${t} hadDate:`,c);const d={datesCompleted:Array.from(i),completed:i.has(e),updatedAt:new Date().toISOString(),streak:c?Math.max(0,(n.streak??0)-1):(n.streak??0)+1};console.log(`[remoteHabitsService] checkInHabit ${t} update:`,d);const u=Array.isArray(n.datesCompleted)&&n.datesCompleted.some(C=>typeof C=="object"&&typeof C?.toDate=="function");try{u?(console.log("[remoteHabitsService] detected Timestamp entries in stored dates — using full-array update"),await y(o,d)):c?await y(o,{updatedAt:d.updatedAt,datesCompleted:J(e),completed:d.completed,streak:d.streak}):await y(o,{updatedAt:d.updatedAt,datesCompleted:ue(e),completed:d.completed,streak:d.streak})}catch(C){console.warn("[remoteHabitsService] Atomic arrayOp failed or full-array update failed, falling back to full array set:",C),await y(o,d)}const m=await g(o);if(!m.exists())throw new Error("Habit not found after update");console.log(`[remoteHabitsService] checkInHabit ${t} completed`),console.log("[remoteHabitsService] updatedSnap raw dates:",m.data()?.datesCompleted);const w=m.data(),S=Array.isArray(w.datesCompleted)?w.datesCompleted.map(P):[],b=typeof w.completed=="boolean"?w.completed:S.length>0;Ot&&console.log("[remoteHabitsService] updated normalized dates:",S);try{const C=w.userId||r||"";if(C){const Q=x(C).map(N=>N.id===m.id?{id:m.id,...w,datesCompleted:S}:N),rt=Q.some(N=>N.id===m.id)?Q:[{id:m.id,...w,datesCompleted:S}].concat(Q);R(C,rt)}}catch{}return{id:m.id,...w,datesCompleted:S,completed:b}}catch(a){console.error(`[remoteHabitsService] Failed to check-in habit ${t}:`,a);const n=String(a?.code||a?.message||a);if(n.toLowerCase().includes("permission")||n.toLowerCase().includes("insufficient")){console.warn("[remoteHabitsService] Permission error — falling back to local check-in");try{const{auth:s}=await he(async()=>{const{auth:d}=await Promise.resolve().then(()=>je);return{auth:d}},void 0),i=s.currentUser?.uid;if(!i)throw new Error("No authenticated user for local fallback");return await z.checkInHabit(t,e,i)}catch(s){throw console.error("[remoteHabitsService] Local fallback check-in failed:",s),a}}throw a}}},F=vt?z:xt,Ut=async()=>{if(!G)return!1;try{return await Ge()}catch{return!1}},U={trackEvent:async(t,e)=>{if(await Ut())try{const o=$e(G);dt(o,t,e)}catch{return}}},Rt={items:[],loading:!1,error:null,pending:{}},X=f("habits/fetch",async t=>{if(!t){const e=l.currentUser?.uid;return e?await F.getHabits(e):[]}return await F.getHabits(t)}),Ft=f("habits/create",async t=>{const e=l.currentUser?.uid;if(!e)throw new Error("Not authenticated");const r={...t,userId:e},o=await F.addHabit(r);return U.trackEvent("create_habit",{habitId:o.id}),o}),Tt=f("habits/update",async({id:t,data:e})=>{const r=l.currentUser?.uid;if(!r)throw new Error("Not authenticated");return await F.updateHabit(t,{...e,userId:r})}),Gt=f("habits/delete",async t=>{const e=l.currentUser?.uid;if(!e)throw new Error("Not authenticated");return await F.deleteHabit(t,e),t}),De=f("habits/checkIn",async({id:t,date:e})=>{const r=l.currentUser?.uid;if(!r)throw new Error("Not authenticated");return await F.checkInHabit(t,e,r)}),ze=T({name:"habits",initialState:Rt,reducers:{toggleLocalComplete(t,e){const r=e.payload,o=t.items.find(s=>s.id===r);if(!o)return;const a=new Date().toISOString().split("T")[0],n=new Set(o.datesCompleted??[]);n.has(a)?n.delete(a):n.add(a),o.datesCompleted=Array.from(n),o.completed=n.size>0,o.updatedAt=new Date().toISOString(),t.pending[r]=Date.now()},applyLocalCheckIn(t,e){const{id:r,date:o}=e.payload,a=t.items.find(s=>s.id===r);if(!a)return;const n=new Set(a.datesCompleted??[]);n.has(o)?n.delete(o):n.add(o),a.datesCompleted=Array.from(n),a.completed=n.size>0,a.updatedAt=new Date().toISOString(),t.pending[r]=Date.now()}},extraReducers:t=>{t.addCase(X.pending,e=>{e.loading=!0,e.error=null}).addCase(X.fulfilled,(e,r)=>{e.loading=!1;const o=r.payload,a=new Map;for(const n of e.items)a.set(n.id,n);for(const n of o){const s=a.get(n.id);if(new Set(n.datesCompleted??[]),!s){const C=e.pending[n.id],ye=n.updatedAt?Date.parse(n.updatedAt):0;if(C&&C>ye)continue;a.set(n.id,n);continue}const i=e.pending[n.id],c=n.updatedAt?Date.parse(n.updatedAt):0;if(i&&i>c){a.set(s.id,s);continue}const d=new Set([...s.datesCompleted??[],...n.datesCompleted??[]]),u=Array.from(d).sort(),m=u.length>0,w=s.updatedAt?Date.parse(s.updatedAt):0,S=n.updatedAt&&Date.parse(n.updatedAt)>w?n.updatedAt:s.updatedAt,b={...s,...n,datesCompleted:u,completed:m,updatedAt:S};a.set(n.id,b)}e.items=Array.from(a.values())}).addCase(X.rejected,(e,r)=>{e.loading=!1,e.error=r.error.message||"Failed to fetch"}).addCase(Ft.fulfilled,(e,r)=>{e.items.unshift(r.payload)}).addCase(Tt.fulfilled,(e,r)=>{const o=e.items.findIndex(a=>a.id===r.payload.id);o>=0&&(e.items[o]=r.payload)}).addCase(Gt.fulfilled,(e,r)=>{e.items=e.items.filter(o=>o.id!==r.payload)}).addCase(De.fulfilled,(e,r)=>{const o=r.payload,a=e.items.findIndex(n=>n.id===o.id);if(a>=0){const n=e.items[a],s=n.updatedAt?Date.parse(n.updatedAt):0;(o.updatedAt?Date.parse(o.updatedAt):0)>=s?e.items[a]={...n,datesCompleted:o.datesCompleted??n.datesCompleted,completed:typeof o.completed=="boolean"?o.completed:o.datesCompleted?o.datesCompleted.length>0:n.completed,updatedAt:o.updatedAt??n.updatedAt,streak:typeof o.streak=="number"?o.streak:n.streak}:e.items[a]={...n}}else e.items.push(o);o.id&&e.pending[o.id]&&delete e.pending[o.id]}).addCase(De.rejected,(e,r)=>{const o=r.meta&&r.meta.arg||null,a=o?o.id:null;a&&e.pending[a]&&delete e.pending[a]})}}),{applyLocalCheckIn:cr}=ze.actions,$t=ze.reducer;async function Lt(){try{if(!l.app.options.apiKey)return{success:!1,error:"Firebase API Key отсутствует"};if(!l.app.options.authDomain)return{success:!1,error:"Firebase Auth Domain отсутствует"};if(!l.app.options.projectId)return{success:!1,error:"Firebase Project ID отсутствует"};const t=l.app.options.authDomain;return!t.includes("firebaseapp.com")&&!t.includes("web.app")&&console.warn("Auth Domain не выглядит как стандартный Firebase домен:",t),console.log("Firebase configuration check passed"),{success:!0}}catch(t){return console.error("Firebase configuration check failed:",t),{success:!1,error:t instanceof Error?t.message:"Неизвестная ошибка конфигурации"}}}function Ht(){return{apiKey:l.app.options.apiKey?`${l.app.options.apiKey.substring(0,10)}...`:"missing",authDomain:l.app.options.authDomain||"missing",projectId:l.app.options.projectId||"missing",currentDomain:window.location.hostname,protocol:window.location.protocol}}const Je={login:async(t,e)=>{if(window.Cypress){if(console.log("E2E: Mocking login",{email:t}),t.includes("wrong")||t.includes("error")||e==="short"){const o=new Error("Firebase: Error (auth/invalid-email).");throw o.code="auth/invalid-credential",t.includes("user-not-found")&&(o.code="auth/user-not-found"),e==="short"&&(o.code="auth/weak-password"),o}return{uid:"test-user-id",email:t,displayName:"Test User",photoURL:null,emailVerified:!0,getIdToken:async()=>"mock-token"}}const r=await mt(l,t,e);if(!r.user.emailVerified){await Se(l);const o=new Error("Email не подтвержден. Проверьте вашу почту и перейдите по ссылке из письма.");throw o.code="auth/email-not-verified",o}return U.trackEvent("login",{method:"email"}),r.user},register:async(t,e,r)=>{if(window.Cypress){if(console.log("E2E: Mocking register",{email:t}),t.includes("existing")||t.includes("used")){const a=new Error("Firebase: Error (auth/email-already-in-use).");throw a.code="auth/email-already-in-use",a}return{uid:"test-user-id",email:t,displayName:r||"Test User",photoURL:null,emailVerified:!0,getIdToken:async()=>"mock-token"}}const o=await ht(l,t,e);if(r)try{const a=o.user;a&&typeof a.getIdToken=="function"&&await Le(o.user,{displayName:r})}catch(a){console.warn("updateProfile skipped or failed:",a)}try{await Ce(o.user,{url:`${window.location.origin}/email-verified`,handleCodeInApp:!1}),console.log("Verification email sent to:",t)}catch(a){console.error("Failed to send verification email:",a)}return U.trackEvent("signup",{method:"email"}),o.user},logout:async()=>{if(window.Cypress){console.log("E2E: Mocking logout");return}await Se(l)},googleLogin:async()=>{if(window.Cypress){console.log("E2E: Mocking googleLogin");const t={uid:"test-user-id",email:"test@example.com",displayName:"Test User",photoURL:null,getIdToken:async()=>"mock-token"};return localStorage.setItem("cypress_user",JSON.stringify({uid:t.uid,email:t.email,displayName:t.displayName,photoURL:t.photoURL})),t}try{console.log("Checking Firebase configuration...");const t=await Lt();if(!t.success)throw console.error("Firebase configuration invalid:",t.error),new Error(`Ошибка конфигурации Firebase: ${t.error}`);console.log("Firebase debug info:",Ht()),console.log("Initializing Google OAuth...");const e=new pt;e.addScope("profile"),e.addScope("email"),e.setCustomParameters({prompt:"select_account"});const r=window.location.protocol==="http:";if(console.log("Protocol:",window.location.protocol),console.log("Using redirect method:",r),r)throw console.log("Starting Google sign-in with redirect (http protocol)..."),await ft(l,e),new Error("REDIRECT_IN_PROGRESS");{console.log("Opening Google sign-in popup (https)...");const o=await gt(l,e);return console.log("Google sign-in successful:",o.user.email),U.trackEvent("login",{method:"google"}),o.user}}catch(t){if(t instanceof Error&&t.message==="REDIRECT_IN_PROGRESS")throw t;console.error("Google login error:",t);const e=t;throw e.code==="auth/internal-error"?(console.error("Internal error detected. Possible causes: Google API timeout, CORS, network issues."),new Error("Не удалось загрузить Google OAuth. Попробуйте: 1) Отключить блокировщики рекламы, 2) Проверить интернет-соединение, 3) Использовать другой браузер.")):e.code==="auth/unauthorized-domain"?new Error(`Домен не авторизован. Добавьте "${window.location.hostname}" в Firebase Console: Authentication → Settings → Authorized domains`):e.code==="auth/popup-closed-by-user"?new Error("Окно авторизации было закрыто. Попробуйте снова."):e.code==="auth/popup-blocked"?new Error("Браузер заблокировал всплывающее окно. Разрешите всплывающие окна для этого сайта."):e.code==="auth/cancelled-popup-request"?new Error("Запрос авторизации был отменен."):e.code==="auth/network-request-failed"?new Error("Ошибка сети. Проверьте подключение к интернету."):t}},checkGoogleRedirectResult:async()=>{try{console.log("Checking for redirect result...");const t=await ut(l);return t?(console.log("Google sign-in successful after redirect:",t.user.email),U.trackEvent("login",{method:"google"}),t.user):null}catch(t){throw console.error("Redirect result error:",t),t.code==="auth/internal-error"?new Error("Не удалось завершить вход через Google. Попробуйте снова."):t}},sendVerificationEmail:async()=>{if(window.Cypress){console.log("E2E: Mocking sendVerificationEmail");return}const t=l.currentUser;if(!t)throw new Error("Пользователь не авторизован");if(t.emailVerified)throw new Error("Email уже подтвержден");await Ce(t,{url:`${window.location.origin}/email-verified`,handleCodeInApp:!1}),console.log("Verification email sent to:",t.email)},verifyEmailCode:async t=>{if(window.Cypress){console.log("E2E: Mocking verifyEmailCode");return}try{await ct(l,t),await lt(l,t),l.currentUser&&await l.currentUser.reload(),console.log("Email verified successfully"),U.trackEvent("email_verified")}catch(e){console.error("Email verification error:",e);const r=e;throw r.code==="auth/invalid-action-code"?new Error("Неверный или истекший код подтверждения"):r.code==="auth/expired-action-code"?new Error("Код подтверждения истек. Запросите новое письмо."):e}},checkEmailVerified:async()=>{if(window.Cypress)return!0;const t=l.currentUser;return t?(await t.reload(),t.emailVerified):!1},deleteAccount:async()=>{if(window.Cypress){console.log("E2E: Mocking deleteAccount");return}const t=l.currentUser;t&&await t.delete()}},_t={loading:!1,error:null,me:null,isAuthenticated:!1},me=t=>({id:t.uid,email:t.email??null,name:t.displayName??null,photoURL:t.photoURL??null}),B=t=>t instanceof Error?t.message:String(t),Y=f("user/fetchMe",async(t,{rejectWithValue:e})=>{const r=l.currentUser;if(!r)return null;try{return me(r)}catch(o){return e(B(o)||"Failed to map user")}}),Z=f("user/updateMe",async(t,{rejectWithValue:e})=>{const r=l.currentUser;if(!r)return e("No authenticated user");try{const o={};return t.name!==void 0&&(o.displayName=t.name),t.photoURL!==void 0&&(o.photoURL=t.photoURL),Object.keys(o).length>0&&await Le(r,o),me(r)}catch(o){return e(B(o)||"Failed to update profile")}}),ee=f("user/initAuth",async(t,{dispatch:e})=>{if(!!window.Cypress||typeof window.Cypress<"u"){console.log("E2E: Mocking auth initialization");const o=localStorage.getItem("cypress_user");if(console.log("E2E: Stored user in localStorage:",o),o)try{const a=JSON.parse(o);console.log("E2E: Parsed user:",a),e(Ie({id:a.uid,email:a.email,name:a.displayName,photoURL:a.photoURL})),console.log("E2E: User set in Redux store")}catch(a){console.error("Failed to parse cypress_user",a)}else console.log("E2E: No cypress_user found in localStorage");return}return new Promise((o,a)=>{const n=setTimeout(()=>{a(new Error("Auth initialization timeout"))},1e4),s=wt(l,i=>{clearTimeout(n),e(i?Ie(me(i)):ke()),s(),o()},i=>{clearTimeout(n),console.error("Auth state change error:",i),e(ke()),s(),a(i)})})}),te=f("user/logout",async(t,{rejectWithValue:e})=>{try{await Je.logout()}catch(r){return e(B(r)||"Failed to logout")}}),re=f("user/deleteAccount",async(t,{rejectWithValue:e})=>{try{await Je.deleteAccount()}catch(r){return e(B(r)||"Failed to delete account")}}),qe=T({name:"user",initialState:_t,reducers:{setUser(t,e){t.me=e.payload,t.isAuthenticated=!0,t.loading=!1,t.error=null},clearUser(t){t.me=null,t.isAuthenticated=!1,t.loading=!1,t.error=null},setLoading(t,e){t.loading=e.payload},setError(t,e){t.error=e.payload}},extraReducers:t=>{t.addCase(Y.pending,e=>{e.loading=!0,e.error=null}).addCase(Y.fulfilled,(e,r)=>{e.loading=!1,r.payload?(e.me=r.payload,e.isAuthenticated=!0):(e.me=null,e.isAuthenticated=!1)}).addCase(Y.rejected,(e,r)=>{e.loading=!1,e.error=r.payload||r.error.message||"Failed to fetch user"}).addCase(Z.pending,e=>{e.loading=!0,e.error=null}).addCase(Z.fulfilled,(e,r)=>{e.loading=!1,e.me=r.payload,e.isAuthenticated=!0}).addCase(Z.rejected,(e,r)=>{e.loading=!1,e.error=r.payload||r.error.message||"Failed to update user"}).addCase(ee.pending,e=>{e.loading=!0}).addCase(ee.fulfilled,e=>{e.loading=!1}).addCase(ee.rejected,(e,r)=>{e.loading=!1,e.error=r.error.message||"Auth init failed"}).addCase(te.pending,e=>{e.loading=!0}).addCase(te.fulfilled,e=>{e.me=null,e.isAuthenticated=!1,e.loading=!1,e.error=null}).addCase(te.rejected,(e,r)=>{e.loading=!1,e.error=r.payload||r.error.message||"Logout failed"}).addCase(re.pending,e=>{e.loading=!0}).addCase(re.fulfilled,e=>{e.me=null,e.isAuthenticated=!1,e.loading=!1,e.error=null}).addCase(re.rejected,(e,r)=>{e.loading=!1,e.error=r.payload||r.error.message||"Delete account failed"})}}),{setUser:Ie,clearUser:ke,setLoading:lr,setError:ur}=qe.actions,Nt=qe.reducer;var jt={};const M="goals",Pt=typeof process<"u"&&(jt.VITEST==="true"||!1)||typeof window<"u"&&typeof window.Cypress<"u"&&window.Cypress===!0,Ke=new Map,Be=t=>`motify_goals_${t}`;function We(){return typeof window<"u"?window.localStorage:null}function V(t){if(!t)return[];const e=Be(t),o=We()?.getItem(e)??Ke.get(e);if(!o)return[];try{const a=JSON.parse(o);return Array.isArray(a)?a.map(n=>({...n})):[]}catch{return[]}}function oe(t,e){if(!t)return e;const r=Be(t),o=JSON.stringify(e),a=We();return a?a.setItem(r,o):Ke.set(r,o),e}const Mt={async getGoals(t){return V(t)},async addGoal(t){const e=V(t.userId),r={...t,id:typeof crypto<"u"&&crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),progress:t.progress??0,completed:t.completed??!1};return oe(t.userId,[r,...e]),r},async updateGoal(t,e){const r=V(e.userId);let o=null;const a=r.map(n=>{if(n.id!==t)return n;const s={...n,...e,updatedAt:new Date().toISOString()};return o=s,s});if(!o)throw new Error("Goal not found");return oe(e.userId,a),o},async deleteGoal(t,e){const r=V(e);oe(e,r.filter(o=>o.id!==t))}},Vt={async getGoals(t){if(!t)return[];try{const e=pe(A(p,M),fe("userId","==",t));return(await _(e)).docs.map(o=>({id:o.id,...o.data()}))}catch(e){return console.error("Error fetching goals:",e),[]}},async addGoal(t){try{const e={userId:t.userId,title:t.title||"",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),progress:typeof t.progress=="number"?t.progress:0,completed:!!t.completed};t.detailedDescription&&typeof t.detailedDescription=="string"&&t.detailedDescription.trim()!==""&&(e.detailedDescription=t.detailedDescription),t.tasks&&Array.isArray(t.tasks)&&t.tasks.length>0&&(e.tasks=t.tasks.map(a=>({id:a.id,title:a.title,done:!!a.done}))),console.log("Clean goal before Firestore:",JSON.stringify(e,null,2));const r=await H(A(p,M),e),o={...e,id:r.id};return console.log("Goal added successfully with ID:",r.id),o}catch(e){throw console.error("Error adding goal:",e),console.error("Goal object that failed:",t),new Error(`Failed to add goal: ${e instanceof Error?e.message:"Unknown error"}`)}},async updateGoal(t,e){const r=h(p,M,t);if(!(await g(r)).exists())throw new Error(`Goal with id ${t} not found`);const a={...e,updatedAt:new Date().toISOString()},{id:n,...s}=a;await y(r,s);const i=await g(r);if(!i.exists())throw new Error("Goal not found after update");return{id:i.id,...i.data()}},async deleteGoal(t,e){await O(h(p,M,t))}},L=Pt?Mt:Vt,zt={items:[],loading:!1,error:null},ae=f("goals/fetchAll",async t=>{if(!t){const e=l.currentUser?.uid;return e?await L.getGoals(e):[]}return await L.getGoals(t)}),Jt=f("goals/add",async t=>{const e=l.currentUser?.uid;if(!e)throw new Error("Not authenticated");const r={...t,userId:e};return await L.addGoal(r)}),qt=f("goals/update",async({id:t,data:e})=>{const r=l.currentUser?.uid;if(!r)throw new Error("Not authenticated");return await L.updateGoal(t,{...e,userId:r})}),Kt=f("goals/delete",async t=>{const e=l.currentUser?.uid;if(!e)throw new Error("Not authenticated");return await L.deleteGoal(t,e),t}),Bt=T({name:"goals",initialState:zt,reducers:{},extraReducers:t=>{t.addCase(ae.pending,e=>{e.loading=!0,e.error=null}).addCase(ae.fulfilled,(e,r)=>{e.loading=!1,e.items=r.payload}).addCase(ae.rejected,(e,r)=>{e.loading=!1,e.error=r.error.message??"Failed to fetch goals"}).addCase(Jt.fulfilled,(e,r)=>{e.items.unshift(r.payload)}).addCase(qt.fulfilled,(e,r)=>{const o=e.items.findIndex(a=>a.id===r.payload.id);o>=0&&(e.items[o]=r.payload)}).addCase(Kt.fulfilled,(e,r)=>{e.items=e.items.filter(o=>o.id!==r.payload)})}}),Wt=Bt.reducer;var Qt={};const E="challenges",we=typeof process<"u"&&(Qt.VITEST==="true"||!1)||typeof window<"u"&&typeof window.Cypress<"u"&&window.Cypress===!0;typeof window<"u"&&console.log("[ChallengesService] isTest:",we,"Cypress:",typeof window.Cypress,"Value:",window.Cypress);const Qe=new Map,q="motify_challenges";function Xe(){return typeof window<"u"?window.localStorage:null}function D(){const e=Xe()?.getItem(q)??Qe.get(q);if(!e)return[];try{const r=JSON.parse(e);return Array.isArray(r)?r:[]}catch{return[]}}function I(t){const e=JSON.stringify(t),r=Xe();return r?r.setItem(q,e):Qe.set(q,e),t}const Ye={async getChallenges(){console.log("[localChallengesService] getChallenges called");const t=D();if(console.log("[localChallengesService] challenges from localStorage:",t.length),t.length===0){const e={id:"demo-30-day-challenge",title:"30-дневный вызов привычек",description:"Создайте и поддерживайте ежедневные привычки в течение 30 дней",days:30,startDate:new Date().toISOString(),participants:[],dailyChecks:{},createdAt:new Date().toISOString()};return console.log("[localChallengesService] No challenges found, creating demo"),I([e]),[e]}return t},async addChallenge(t){const e=D(),r={...t,id:typeof crypto<"u"&&crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),participants:t.participants??[],dailyChecks:t.dailyChecks??{}};return I([...e,r]),r},async updateChallenge(t,e){const r=D(),o=r.findIndex(n=>n.id===t);if(o===-1)throw new Error("Challenge not found");const a={...r[o],...e,updatedAt:new Date().toISOString()};return r[o]=a,I(r),a},async deleteChallenge(t){const e=D();I(e.filter(r=>r.id!==t))},async joinChallenge(t,e){const r=D(),o=r.findIndex(i=>i.id===t);if(o===-1)throw new Error("Challenge not found");const a=r[o],n=a.participants??[];if(n.includes(e))return a;const s={...a,participants:[...n,e],updatedAt:new Date().toISOString()};return r[o]=s,I(r),s},async leaveChallenge(t,e){const r=D(),o=r.findIndex(i=>i.id===t);if(o===-1)throw new Error("Challenge not found");const a=r[o],n=a.participants??[],s={...a,participants:n.filter(i=>i!==e),updatedAt:new Date().toISOString()};return r[o]=s,I(r),s},async checkInChallenge(t,e,r){const o=D(),a=o.findIndex(m=>m.id===t);if(a===-1)throw new Error("Challenge not found");const n=o[a],s=n.dailyChecks??{};let i=s[e]??[];const c=r??new Date().toISOString().split("T")[0];if(i.includes(c))return n;if((n.mode??"cumulative")==="streak"&&i.length>0){const m=[...i].sort(),w=m[m.length-1],S=new Date(w),b=new Date(c);Math.floor((b.getTime()-S.getTime())/(1e3*60*60*24))>1&&(i=[],n.lastResetDate=c)}const u={...n,dailyChecks:{...s,[e]:[...i,c]},updatedAt:new Date().toISOString()};return o[a]=u,I(o),u},async undoCheckIn(t,e,r){const o=D(),a=o.findIndex(u=>u.id===t);if(a===-1)throw new Error("Challenge not found");const n=o[a],s=n.dailyChecks??{},i=s[e]??[],c=r??new Date().toISOString().split("T")[0];if(!i.includes(c))return n;const d={...n,dailyChecks:{...s,[e]:i.filter(u=>u!==c)},updatedAt:new Date().toISOString()};return o[a]=d,I(o),d}},Xt={async getChallenges(){try{const t=h(p,E,"demo-30-day-challenge"),e=await g(t);if(e.exists())console.log("[remoteChallengesService] Demo challenge exists:",{id:e.id,participants:e.data()?.participants,participantsCount:e.data()?.participants?.length||0});else{const s={title:"30-дневный вызов привычек",description:"Создайте и поддерживайте ежедневные привычки в течение 30 дней",days:30,startDate:new Date().toISOString(),participants:[],dailyChecks:{},createdAt:new Date().toISOString()};let i=!1;try{await j(t,s);let c=await g(t),d=0;for(;!c.exists()&&d<3;)d++,console.warn(`demoDoc creation not visible yet, retrying (${d})...`),await new Promise(u=>setTimeout(u,500)),c=await g(t);if(!c.exists())throw console.error("Failed to create demo challenge after retries"),new Error("Challenge with id demo-30-day-challenge not found");console.log("Demo challenge created with ID: demo-30-day-challenge"),i=!0}catch(c){console.error("[remoteChallengesService] Failed to set demo challenge in Firestore:",c),console.error("[remoteChallengesService] Falling back to local demo")}}const o=(await _(A(p,E))).docs.map(s=>{const i=s.data();if("id"in i){const c={...i};return delete c.id,{id:s.id,...c}}return{id:s.id,...i}});console.log("[remoteChallengesService] Loaded challenges total:",o.length),o.forEach((s,i)=>{console.log(`  Challenge[${i}]: id="${s.id}", title="${s.title}", participants=${s.participants?.length||0}`)});const a=o.filter(s=>s.id==="demo-30-day-challenge");if(a.length>1){console.log("[remoteChallengesService] MULTIPLE demo challenges found! Deleting extras..."),a.sort((d,u)=>(u.participants?.length||0)-(d.participants?.length||0));const s=a[0],i=a.slice(1);for(const d of i)try{console.log(`  Deleting duplicate demo challenge with ${d.participants?.length||0} participants`),await O(h(p,E,d.id))}catch(u){console.error("  Failed to delete duplicate:",u)}const c=[s];return console.log("[remoteChallengesService] RETURNING challenges:",c.length),c.forEach((d,u)=>{console.log(`  RETURN[${u}]: id="${d.id}", participants=${d.participants?.length||0}, participantsList=${JSON.stringify(d.participants)}`)}),c}const n=o.filter(s=>s.id!=="demo-30-day-challenge"&&s.title==="30-дневный вызов привычек");if(n.length>0){console.log("[remoteChallengesService] Found duplicates with different IDs to cleanup:",n.length);for(const s of n)try{console.log(`  Deleting duplicate challenge: ${s.id}`),await O(h(p,E,s.id))}catch(i){console.error("  Failed to delete duplicate:",i)}}if(a.length>0)return console.log("[remoteChallengesService] RETURNING challenges from server:",a.length),a.forEach((s,i)=>{console.log(`  RETURN[${i}]: id="${s.id}", participants=${s.participants?.length||0}, participantsList=${JSON.stringify(s.participants)}`)}),a;try{const s=await Ye.getChallenges();return console.log("[remoteChallengesService] Falling back to local challenges:",s.length),s}catch(s){return console.error("[remoteChallengesService] Failed to read local challenges as fallback:",s),[]}}catch(t){return console.error("Error fetching challenges:",t),[]}},async addChallenge(t){const e={...t,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),participants:t.participants??[],dailyChecks:t.dailyChecks??{}},r=await H(A(p,E),e);return{...e,id:r.id}},async updateChallenge(t,e){const r=h(p,E,t),o={...e,updatedAt:new Date().toISOString()},{id:a,...n}=o;await y(r,n);const s=await g(r);if(!s.exists())throw new Error("Challenge not found");return{id:s.id,...s.data()}},async deleteChallenge(t){await O(h(p,E,t))},async joinChallenge(t,e){const r=h(p,E,t);let o=await g(r);if(!o.exists())if(t==="demo-30-day-challenge"){console.warn(`Demo challenge ${t} not found, создавая его`);const i={title:"30-дневный вызов привычек",description:"Создайте и поддерживайте ежедневные привычки в течение 30 дней",days:30,startDate:new Date().toISOString(),participants:[],dailyChecks:{},createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};await j(r,i),o=await g(r);let c=await g(r),d=0;for(;!c.exists()&&d<3;)d++,console.warn(`demoDoc creation not visible yet, retrying (${d})...`),await new Promise(u=>setTimeout(u,500)),c=await g(r);if(!c.exists())throw console.error("Failed to create demo challenge after retries"),new Error("Challenge with id demo-30-day-challenge not found");console.log("Demo challenge created with ID: demo-30-day-challenge")}else throw console.error(`Challenge ${t} not found in Firestore`),new Error(`Challenge with id ${t} not found`);console.log(`Joining challenge ${t} for user ${e}`);const a=o&&typeof o.data=="function"?o.data():void 0;console.log("Current participants BEFORE update:",a?.participants||[]);try{await y(r,{participants:ue(e),updatedAt:new Date().toISOString()}),console.log(`Challenge ${t} updated successfully`)}catch(i){throw console.error(`FAILED to update challenge ${t}:`,i),console.error("Error code:",i?.code),console.error("Error message:",i?.message),i}const n=await g(r);if(!n.exists())throw new Error("Challenge not found after update");const s={id:n.id,...n.data()};return console.log("Challenge participants AFTER update:",s.participants),console.log(`User ${e} is now participating:`,s.participants?.includes(e)),s},async leaveChallenge(t,e){const r=h(p,E,t);let o=await g(r);if(!o.exists())if(t==="demo-30-day-challenge"){console.warn(`Demo challenge ${t} not found on leave, создавая его`);const n={title:"30-дневный вызов привычек",description:"Создайте и поддерживайте ежедневные привычки в течение 30 дней",days:30,startDate:new Date().toISOString(),participants:[],dailyChecks:{},createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};if(await j(r,n),o=await g(r),!o.exists())throw new Error(`Challenge with id ${t} not found`)}else throw new Error(`Challenge with id ${t} not found`);await y(r,{participants:J(e),updatedAt:new Date().toISOString()});const a=await g(r);if(!a.exists())throw new Error("Challenge not found after update");return{id:a.id,...a.data()}},async checkInChallenge(t,e,r){const o=h(p,E,t);let a=await g(o);if(!a.exists())if(t==="demo-30-day-challenge"){console.warn(`Demo challenge ${t} not found on checkIn, создавая его`);const u={title:"30-дневный вызов привычек",description:"Создайте и поддерживайте ежедневные привычки в течение 30 дней",days:30,startDate:new Date().toISOString(),participants:[],dailyChecks:{},createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};if(await j(o,u),a=await g(o),!a.exists())throw new Error(`Challenge with id ${t} not found`)}else throw new Error(`Challenge with id ${t} not found`);const n=a.data(),s=n.dailyChecks??{},i=s[e]??[],c=r??new Date().toISOString().split("T")[0];if(i.includes(c))return Object.assign({id:a.id},n);s[e]=[...i,c],await y(o,{dailyChecks:s,updatedAt:new Date().toISOString()});const d=await g(o);if(!d.exists())throw new Error("Challenge not found after update");return{id:d.id,...d.data()}},async undoCheckIn(t,e,r){const o=h(p,E,t);if(!(await g(o)).exists())throw new Error("Challenge not found");const n=r??new Date().toISOString().split("T")[0];await y(o,{[`dailyChecks.${e}`]:J(n),updatedAt:new Date().toISOString()});const s=await g(o);return{id:s.id,...s.data()}}},k=we?Ye:Xt;typeof window<"u"&&(console.log("[ChallengesService] Using:",we?"localStorage (local)":"Firestore (remote)"),console.log("[ChallengesService] Service methods:",Object.keys(k)),console.log("[ChallengesService] joinChallenge is:",k.joinChallenge.toString().slice(0,200)));const Yt={items:[],loading:!1,error:null},ne=f("challenges/fetchChallenges",async(t,{rejectWithValue:e})=>{try{return await k.getChallenges()}catch(r){return e(r instanceof Error?r.message:"Failed to fetch challenges")}}),se=f("challenges/createChallenge",async(t,{rejectWithValue:e})=>{try{return await k.addChallenge(t)}catch(r){return e(r instanceof Error?r.message:"Failed to create challenge")}}),be=f("challenges/joinChallenge",async({challengeId:t,userId:e},{rejectWithValue:r})=>{try{return await k.joinChallenge(t,e)}catch(o){return r(o instanceof Error?o.message:"Failed to join challenge")}}),ve=f("challenges/leaveChallenge",async({challengeId:t,userId:e},{rejectWithValue:r})=>{try{return await k.leaveChallenge(t,e)}catch(o){return r(o instanceof Error?o.message:"Failed to leave challenge")}}),Oe=f("challenges/checkInChallenge",async({challengeId:t,userId:e,date:r},{rejectWithValue:o})=>{try{return await k.checkInChallenge(t,e,r)}catch(a){return o(a instanceof Error?a.message:"Failed to check in challenge")}}),xe=f("challenges/undoCheckIn",async({challengeId:t,userId:e,date:r},{rejectWithValue:o})=>{try{return await k.undoCheckIn(t,e,r)}catch(a){return o(a instanceof Error?a.message:"Failed to undo check in")}}),Ze=T({name:"challenges",initialState:Yt,reducers:{clearChallengesError(t){t.error=null}},extraReducers:t=>{t.addCase(ne.pending,e=>{e.loading=!0,e.error=null}).addCase(ne.fulfilled,(e,r)=>{e.loading=!1,e.items=r.payload}).addCase(ne.rejected,(e,r)=>{e.loading=!1,e.error=r.payload??"Failed to fetch challenges"}).addCase(se.pending,e=>{e.loading=!0,e.error=null}).addCase(se.fulfilled,(e,r)=>{e.loading=!1,e.items.push(r.payload)}).addCase(se.rejected,(e,r)=>{e.loading=!1,e.error=r.payload??"Failed to create challenge"}).addCase(be.fulfilled,(e,r)=>{const o=e.items.findIndex(a=>a.id===r.payload.id);o!==-1&&(e.items[o]=r.payload)}).addCase(be.rejected,(e,r)=>{e.error=r.payload??"Failed to join challenge"}).addCase(ve.fulfilled,(e,r)=>{const o=e.items.findIndex(a=>a.id===r.payload.id);o!==-1&&(e.items[o]=r.payload)}).addCase(ve.rejected,(e,r)=>{e.error=r.payload??"Failed to leave challenge"}).addCase(Oe.fulfilled,(e,r)=>{const o=e.items.findIndex(a=>a.id===r.payload.id);o!==-1&&(e.items[o]=r.payload)}).addCase(Oe.rejected,(e,r)=>{e.error=r.payload??"Failed to check in challenge"}).addCase(xe.fulfilled,(e,r)=>{const o=e.items.findIndex(a=>a.id===r.payload.id);o!==-1&&(e.items[o]=r.payload)}).addCase(xe.rejected,(e,r)=>{e.error=r.payload??"Failed to undo check in"})}}),{clearChallengesError:pr}=Ze.actions,Zt=Ze.reducer,er={items:[],loading:!1,error:null},ie=f("todos/fetchTodos",async t=>{const e=pe(A(p,"todos"),fe("userId","==",t));return(await _(e)).docs.map(o=>({id:o.id,...o.data()}))}),de=f("todos/addTodo",async(t,{rejectWithValue:e})=>{try{const{auth:r}=await he(async()=>{const{auth:i}=await Promise.resolve().then(()=>je);return{auth:i}},void 0),o=r.currentUser;if(!o)throw new Error("User not authenticated");if(o.uid!==t.userId)throw new Error("User ID mismatch");const a=ge.now().toDate().toISOString(),n={title:t.title,completed:!1,createdAt:a,updatedAt:a,userId:o.uid};return t.description?.trim()&&(n.description=t.description.trim()),t.deadline?.trim()&&(n.deadline=t.deadline.trim()),{id:(await H(A(p,"todos"),n)).id,title:t.title,description:t.description||void 0,deadline:t.deadline||void 0,completed:!1,createdAt:a,updatedAt:a,userId:o.uid}}catch(r){const o=r instanceof Error?r.message:String(r);return e(o||"Failed to add todo")}}),Ue=f("todos/toggleTodo",async({id:t,completed:e})=>{const r=h(p,"todos",t);return await y(r,{completed:!e,updatedAt:ge.now().toDate().toISOString()}),{id:t,completed:!e}}),Re=f("todos/deleteTodo",async t=>(await O(h(p,"todos",t)),t)),tr=f("todos/updateTodo",async({id:t,data:e})=>{const r=h(p,"todos",t);return await y(r,{...e,updatedAt:ge.now().toDate().toISOString()}),{id:t,...e}}),rr=T({name:"todos",initialState:er,reducers:{},extraReducers:t=>{t.addCase(ie.pending,e=>{e.loading=!0,e.error=null}).addCase(ie.fulfilled,(e,r)=>{e.loading=!1,e.items=r.payload}).addCase(ie.rejected,(e,r)=>{e.loading=!1,e.error=r.error.message||"Failed to fetch todos"}).addCase(de.pending,e=>{e.loading=!0,e.error=null}).addCase(de.fulfilled,(e,r)=>{e.loading=!1,e.items.push(r.payload)}).addCase(de.rejected,(e,r)=>{e.loading=!1,e.error=r.error.message||"Failed to add todo"}).addCase(Ue.rejected,(e,r)=>{e.error=r.error.message||"Failed to toggle todo"}).addCase(Ue.fulfilled,(e,r)=>{const o=e.items.find(a=>a.id===r.payload.id);o&&(o.completed=r.payload.completed)}).addCase(tr.fulfilled,(e,r)=>{const o=e.items.findIndex(a=>a.id===r.payload.id);o!==-1&&(e.items[o]={...e.items[o],...r.payload})}).addCase(Re.rejected,(e,r)=>{e.error=r.error.message||"Failed to delete todo"}).addCase(Re.fulfilled,(e,r)=>{e.items=e.items.filter(o=>o.id!==r.payload)})}}),or=rr.reducer,v="groups",W={async getGroups(){try{return(await _(A(p,v))).docs.map(e=>({id:e.id,...e.data()}))}catch(t){return console.error("Error fetching groups:",t),[]}},async getGroupById(t){try{const e=h(p,v,t),r=await g(e);return r.exists()?{id:r.id,...r.data()}:null}catch(e){return console.error("Error fetching group:",e),null}},async createGroup(t){try{const e={...t,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),members:t.members??[t.ownerId]},r=await H(A(p,v),e);return{...e,id:r.id}}catch(e){console.error("Error creating group:",e);const r=e?.message||String(e);throw(e?.code||"").includes("permission")||r.toLowerCase().includes("permission")?new Error("Недостаточно прав для создания группы. Убедитесь, что правила Firestore опубликованы (firebase deploy --only firestore:rules)"):new Error(r)}},async updateGroup(t,e){try{const r=h(p,v,t),o={...e,updatedAt:new Date().toISOString()},{id:a,...n}=o;await y(r,n);const s=await g(r);if(!s.exists())throw new Error("Group not found");return{id:s.id,...s.data()}}catch(r){console.error("Error updating group:",r);const o=r?.message||String(r);throw(r?.code||"").includes("permission")||o.toLowerCase().includes("permission")?new Error("Недостаточно прав для обновления группы. Вы должны быть владельцем или участником."):new Error(o)}},async deleteGroup(t){try{await O(h(p,v,t))}catch(e){console.error("Error deleting group:",e);const r=e?.message||String(e);throw(e?.code||"").includes("permission")||r.toLowerCase().includes("permission")?new Error("Недостаточно прав для удаления группы. Вы должны быть владельцем."):new Error(r)}},async joinGroup(t,e){try{const r=h(p,v,t);await y(r,{members:ue(e),updatedAt:new Date().toISOString()});const o=await g(r);if(!o.exists())throw new Error("Group not found");return{id:o.id,...o.data()}}catch(r){console.error("Error joining group:",r);const o=r?.message||String(r);throw(r?.code||"").includes("permission")||o.toLowerCase().includes("permission")?new Error("Недостаточно прав для присоединения к группе. Убедитесь, что правила Firestore опубликованы."):new Error(o)}},async leaveGroup(t,e){const r=h(p,v,t);await y(r,{members:J(e),updatedAt:new Date().toISOString()});const o=await g(r);if(!o.exists())throw new Error("Group not found");return{id:o.id,...o.data()}}},ar={items:[],loading:!1,error:null},ce=f("groups/fetchGroups",async(t,{rejectWithValue:e})=>{try{return await W.getGroups()}catch(r){return e(r instanceof Error?r.message:"Failed to fetch groups")}}),le=f("groups/createGroup",async(t,{rejectWithValue:e})=>{try{const r=l.currentUser?.uid;if(!r)throw new Error("Not authenticated");return await W.createGroup({...t,ownerId:r})}catch(r){return e(r instanceof Error?r.message:"Failed to create group")}}),Fe=f("groups/updateGroup",async({id:t,data:e},{rejectWithValue:r})=>{try{return await W.updateGroup(t,e)}catch(o){return r(o instanceof Error?o.message:"Failed to update group")}}),Te=f("groups/deleteGroup",async(t,{rejectWithValue:e})=>{try{return await W.deleteGroup(t),t}catch(r){return e(r instanceof Error?r.message:"Failed to delete group")}}),et=T({name:"groups",initialState:ar,reducers:{clearGroupsError(t){t.error=null}},extraReducers:t=>{t.addCase(ce.pending,e=>{e.loading=!0,e.error=null}).addCase(ce.fulfilled,(e,r)=>{e.loading=!1,e.items=r.payload}).addCase(ce.rejected,(e,r)=>{e.loading=!1,e.error=r.payload??"Failed to fetch groups"}).addCase(le.pending,e=>{e.loading=!0,e.error=null}).addCase(le.fulfilled,(e,r)=>{e.loading=!1,e.items.unshift(r.payload)}).addCase(le.rejected,(e,r)=>{e.loading=!1,e.error=r.payload??"Failed to create group"}).addCase(Fe.fulfilled,(e,r)=>{const o=e.items.findIndex(a=>a.id===r.payload.id);o!==-1&&(e.items[o]=r.payload)}).addCase(Fe.rejected,(e,r)=>{e.error=r.payload??"Failed to update group"}).addCase(Te.fulfilled,(e,r)=>{e.items=e.items.filter(o=>o.id!==r.payload)}).addCase(Te.rejected,(e,r)=>{e.error=r.payload??"Failed to delete group"})}}),{clearGroupsError:fr}=et.actions,nr=et.reducer,tt=yt({reducer:{habits:$t,user:Nt,goals:Wt,challenges:Zt,todos:or,groups:nr}}),gr=()=>Ct(),hr=St;const K=document.getElementById("root");if(!K)throw new Error("Root element not found");window.Cypress&&(window.store=tt);K.innerHTML=`
  <div style="padding:24px;color:#fff;background:#111;min-height:100vh;display:flex;flex-direction:column;gap:12px;">
    <div style="font-size:18px;">⚙️ Загрузка приложения…</div>
    <div style="opacity:0.8">Если это сообщение не исчезнет автоматически — произошла ошибка загрузки. Сейчас мы пытаемся восстановить приложение.</div>
  </div>
`;function sr(t){return t.replace(/[&<>"'`]/g,e=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"})[e])}(async()=>{try{const e=(await he(()=>import("./App-BXBS0YwB.js"),__vite__mapDeps([0,1,2]))).default;Et.createRoot(K).render(Ee.jsx(At,{store:tt,children:Ee.jsx(e,{})}))}catch(t){const e=t instanceof Error?t.stack||t.message:String(t);console.error("Dynamic import/render error:",t),K.innerHTML=`<pre style="padding:16px;color:#fff;background:#111;white-space:pre-wrap;">Dynamic import/render error:
${sr(e)}</pre>`}})();try{_e()}catch(t){console.warn("connectEmulators failed:",t)}try{}catch(t){console.warn("initSentry failed:",t)}Ne().catch(t=>console.warn("Analytics init failed:",t));export{te as A,Y as B,re as C,ce as D,le as E,W as F,ee as G,je as H,he as _,Je as a,hr as b,Oe as c,xe as d,l as e,ne as f,X as g,ae as h,ie as i,be as j,de as k,ve as l,Re as m,cr as n,De as o,tr as p,Tt as q,Ft as r,Ie as s,Ue as t,gr as u,Gt as v,qt as w,Jt as x,Kt as y,Z as z};
